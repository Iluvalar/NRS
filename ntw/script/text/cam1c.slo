// SCRIPT file for Cam 1-C

/* General Values */
public		int		player;
public		int		enemy1, enemy2;
public		int		pow1, pow2;
private		int		numart;

private		STRUCTURE	newDroidFactory;


/* structure limit stuff */
public	STRUCTURESTAT		factory, research, oilDerrick, powerGen;
//public	STRUCTURESTAT		powerModuleHack;
public	STRUCTURESTAT		command;
public	INT			numPow, numExt, numFac, numRes;

/* Win or lose */
public		SOUND		lostSnd;
public		LEVEL		NextLev;
public		INT		timeLimit;
private		GROUP		allPlayer, nearLZ;
private		int		totDroids;

public		TEMPLATE	transporter;	//required for enemy transports landing
private		DROID		transportDroid, loadDroid;
private		TEMPLATE	reinforceTemplate;
private		BOOL		transOnMap;

/* Base Under Attack Stuff */
private		STRUCTURE	hitStruc;
private		BASEOBJ		attackerObj, viewerObj, targetObj;
private		int		t;
public		SOUND		attackSnd1;
private		DROID		targetDroid;

/* Briefing stuff */
public		INTMESSAGE		MissionBrief, MissionBrief2, MissionBrief3, MissionBrief4;
//public		INTMESSAGE		NewParadigm_MSG1, NewParadigm_MSG2;
public		SOUND			incomingSnd;
public		INTMESSAGE		endMsg;	//, winMsg;
public		INTMESSAGE		obj0Msg, obj1Msg, obj2Msg;		//enemy LZ's


/* Proximity: Resources */
/*
public		FEATURE		res1;
public		INTMESSAGE	res1Msg;
public		SOUND		res1Snd;
public		STRUCTURESTAT	derrick;
private		int		res1x,res1y;	//temp values to cope with oil disappearing!
*/

/* Proximity: Artifacts */
public		FEATURESTAT	crate;

public		int		art1X, art1Y;
public		STRUCTURE	art1Get;
public		SOUND		art1Snd2;
//public		INTMESSAGE	art1Msg;
public		RESEARCHSTAT	art1Comp;
private		FEATURE		art1ID;

public		int		art2X, art2Y;
public		STRUCTURE	art2Get;
public		SOUND		art2Snd2;
//public		INTMESSAGE	art2Msg;
public		RESEARCHSTAT	art2Comp;
private		FEATURE		art2ID;

public		int		art3X, art3Y;
public		STRUCTURE	art3Get;
public		SOUND		art3Snd2;
//public		INTMESSAGE	art3Msg;
public		RESEARCHSTAT	art3Comp;
private		FEATURE		art3ID;

/* No longer used
public		int		art4X, art4Y;
public		STRUCTURE	art4Get;
public		SOUND		art4Snd2;
//public		INTMESSAGE	art4Msg;
public		RESEARCHSTAT	art4Comp;
private		FEATURE		art4ID;
*/

public		int		art5X, art5Y;
public		STRUCTURE	art5Get;
public		SOUND		art5Snd2;
//public		INTMESSAGE	art5Msg;
public		RESEARCHSTAT	art5Comp;
private		FEATURE		art5ID;

/* player Bonus Research topics given at end of mission */
public	int			numResP0;
public	RESEARCHSTAT		resP0[20];	//need to be declared with value >= numResP0, numResP1, etc.
private	INT			count;

/* Proximity: Enemy */
public		STRUCTURE	enm1a, enm1b, enm1c;
public		STRUCTUREID	enm1aID, enm1bID, enm1cID;

//public		INTMESSAGE	enm1Msg;
//public		SOUND		enm1Snd1;
//public		SOUND		enm1Snd2;

public		STRUCTURE	enm2a, enm2b, enm2c; //enm2d;
public		STRUCTUREID	enm2aID, enm2bID, enm2cID; //enm2dID;

//public		INTMESSAGE	enm2Msg;
//public		SOUND		enm2Snd1;
//public		SOUND		enm2Snd2;

/* AI STUFF */

// enemy1 variables
private		GROUP		enemy1Build, enemy1Attack, enemy1Start, enemy1Fin, enemy1Force1, enemy1Force2;
private		GROUP		enemy2Build, enemy2Attack, enemy2Start, enemy2Fin, enemy1Guard, enemy2Guard;
private		GROUP		Strike3, Ambush1, Reserve1, IDF1, dummy1, dummy2;
private		GROUP		Scav1, Scav2, Scav3;
//public		DROID		sensor1, sensor2;
//public		DROID		Ambush1Droid;	//a Howitzer droid used to figure out when in position!
private		INT		tempInt, tempx1, tempx2, tempy1, tempy2, temp1, temp2;
private		INT		AmbushTot, Scav2Health;	//for keeping track of casualties
public		INT		playerX,playerY;

private		STRUCTURE	attackedStruct;
private		BASEOBJ		attacker;

// temporary variables
private		DROID		newDroid, testDroid;
private		INT		moveX,moveY;
private		INT		xdiff,ydiff;
private		INT		ld;	//default leadership for enemy2

/* values for build lists start here */
/* General Values */
public		int		enemy1Tot;	//limit build to this number
public		int		enemy2Tot;	//limit build to this number

/* Enemy Tactics */
public		TEMPLATE	trike, buggy, bloke, jeep;
public		TEMPLATE	rktJeep, rktBuggy;
public		TEMPLATE	BusCan, FireCan;

public		TEMPLATE	BugRktP, BugHMG, BugSensor;
public		TEMPLATE	ScorpMCan, ScorpMCan2, ScorpLMort;
public		TEMPLATE	scorpTruck;

/* Reinforcement Lists for New Paradigm */
public		INT		numScout, numHeavy;
public		TEMPLATE	scout[3], heavy[3];

/*
public		TEMPLATE	scorpRkt, scorpTank, scorpHow, scorpTruck;
public		TEMPLATE	beetSensor, beetTank;
*/
/* enemy1 */
private		int		enm1aState, enm1bState, enm1cState, atkTot;
private		bool		enm1aDestroyed, enm1bDestroyed, enm1cDestroyed;

/* enemy2 */
private		int		enm2aState, enm2bState, enm2cState; //enm2dState;
private		bool		enm2aDestroyed, enm2bDestroyed, enm2cDestroyed; //enm2dDestroyed;


/* Values for build Commands */
public		DROID		enemyTruck1;	//, enemyTruck2, enemyTruck3;
private		int		comTruck1, comTruck2, comTruck3;
private		INT		dist1, dist2, dist3;		//used to calc closest repair truck!

/* DON'T BOTHER!!!!  Structures to be built
public		INT		numStruc1, numStruc2, numStruc3;
public		STRUCTURESTAT	struc1[6], struc2[2], struc3[19];
public		INT		struc1X[6], struc1Y[6], struc2X[2], struc2Y[2], struc3X[19], struc3Y[19];
 */

private		STRUCTURE	testStruc;	//for checking repair

/* Starting nology */
public		int		numtecE1, numtecE2;
public		RESEARCHSTAT	tecE1[2], tecE2[12];

/* Enemy LZs for 1CA */
public		INT	numLZ, 	enemyLZX[7], enemyLZY[7];
public		SOUND		warnSnd;
private		INT		LZpos;

/* Sectors to check */
public		int		numAtk1Sects;
public		int		atk1SectX1[17], atk1SectY1[17], atk1SectX2[17], atk1SectY2[17];
private		int		as, as1, asX, asY;

/* target acquisition */
public	int	targetMax;
private	int	targetX[2][5], targetY[2][5];

//arrayed version of sector scout!
public	int		st;									//scouts total (2)
private	int		targetCount[2], scoutSector[2], sectInc[2], sn;		//scout number (used in loops)
private	GROUP		Strike1[2], Strike2[2];						//scout and heavy forces
private	int		temp;

//Build oil derricks
public	FEATURESTAT		oilRes;
private FEATURE			feature;
public	int			numDefStructs;
public	STRUCTURESTAT		defStructs[4];
private	int			oilFlag, oilX, oilY;
private	BOOL			boolResult;

/* Enemy Base Blips */
public		int		numBases, basePlayer[10];
public		int		baseRegion[10], baseWav1[10], baseWav2[10];
public		INTMESSAGE	baseMsg[10];
private		int		baseFlag[10];
private		int		basesDead;

public		int		regionsX1[10], regionsY1[10], regionsX2[10], regionsY2[10];
public		SOUND		baseSnd[5];			//base detected/dead

/* Triggers: Win or Lose */
trigger winLoseTrig(every, 5);
trigger gameLostTrig(every, 20);

/* Triggers: Briefing */
trigger vidEndTrig(CALL_VIDEO_QUIT);

/* Triggers: Resource */
/*
trigger res1SeenTrig(droidHasSeen(res1, player), 10);
trigger res1UsedTrig(every, 10);
*/

/* Triggers: Artifacts */
//trigger art1SeenTrig(droidHasSeen(art1ID, player), 5);
trigger art1TakeTrig(droidInRange(player, art1X, art1Y, 171), 5);
trigger art1PlaceTrig((art1Get==NULLOBJECT), 5);

//trigger art2SeenTrig(droidHasSeen(art2ID, player), 5);
trigger art2TakeTrig(droidInRange(player, art2X, art2Y, 171), 5);
trigger art2PlaceTrig((art2Get==NULLOBJECT), 5);

//trigger art3SeenTrig(droidHasSeen(art3ID, player), 5);
trigger art3TakeTrig(droidInRange(player, art3X, art3Y, 171), 5);
trigger art3PlaceTrig((art3Get==NULLOBJECT), 5);

/*
//trigger art4SeenTrig(droidHasSeen(art4ID, player), 5);
trigger art4TakeTrig(droidInRange(player, art4X, art4Y, 171), 5);
trigger art4PlaceTrig((art4Get==NULLOBJECT), 5);
*/

//trigger art5SeenTrig(droidHasSeen(art5ID, player), 5);
trigger art5TakeTrig(droidInRange(player, art5X, art5Y, 171), 5);
trigger art5PlaceTrig((art5Get==NULLOBJECT), 5);

/* Triggers: Enemy */
//trigger enm1SeenTrig(droidHasSeen(enm1a, player), 10);	//enmWait
//trigger enm1DeadTrig(every, 10);			//enmWait

//trigger enm2SeenTrig(droidHasSeen(enm2a, player), 10);	//enmWait
//trigger enm2DeadTrig(every, 10);			//enmWait



/* AI TRIGGERS */

trigger		enemy1AttackPause( every, 3000 );	//5 mins

/* triggers for build lists start here */

/* Triggers: Enemy Tactics */
//trigger enm1aStartTrig(droidInRange(player,enm1a.x, enm1a.y, 15*128),20);
trigger enm1aStartTrig(wait, 20);
trigger enm1aFactTrig(every,900);	//600);
trigger enm1bStartTrig(droidInRange(player,enm1b.x, enm1b.y, 15*128),20);
trigger enm1bFactTrig(every,600);	//400);
trigger enm1cStartTrig(droidInRange(player,enm1c.x, enm1c.y, 15*128),20);
trigger enm1cFactTrig(every,300);	//200);

//trigger enm2aStartTrig(droidInRange(player,enm2a.x, enm2a.y, 15*128),20);
trigger enm2aFactTrig(every,900);	//600);
//trigger enm2bStartTrig(droidInRange(player,enm2b.x, enm2b.y, 15*128),20);
trigger enm2bStartTrig(wait, 3000);	//5 min delay on first factory
trigger enm2bFactTrig(every,600);	//450);
trigger enm2cStartTrig(droidInRange(player,enm2c.x, enm2c.y, 15*128),20);
trigger enm2cFactTrig(every,300);
//trigger enm2dStartTrig(droidInRange(player,enm2d.x, enm2d.y, 15*128),20);
//trigger enm2dFactTrig(every,300);

trigger buildTrig(every, 30);

//Triggers for ordering groups
//trigger orderTrig1((droidInArea(enemy2, 4288, 12480, 6080, 14272)), 20);	//for ambush force to follow
trigger orderTrig1((droidInArea(player, 8896, 13760, 10048, 14656)), 10);	//for ambush force to attack when player through ravine
trigger orderTrig2((droidInArea(player, 6592, 14656, 8896, 15680)), 20);	//for reserve force to protect South of Ravine
trigger orderTrig4(every, 30);							//for checking Ambush in position (so can Hold)

trigger baseTrig (every, 15);


/* transport triggers */
trigger landTransTrig(every, 3000);	//5min delay
trigger landTransTrig2(wait, 100);	//10 second delay
//trigger startTransTrig1(droidInArea(player, 9536, 9024, 15808, 9920), 25);	//start for 1st landing
trigger startTransTrig1(droidInArea(player, 10560, 6400, 16320, 8256), 25);	//Moved Further NORTH!
trigger startTransTrig2(droidInArea(player, 7616, 4800, 9408, 5696), 25);	//start for 2nd landing
trigger stopTransTrig1((numStructsButNotWallsInArea(enemy2, 12992, 3904, 14272, 5568)== 0), 35);	//stop 1st landing
trigger stopTransTrig2((numStructsButNotWallsInArea(enemy2, 8512, 9792, 9664, 10944)== 0), 35);		//stop 2nd landing

trigger obj0Trig(droidInRange(player, 6848, 13888, 5*128), 20);

/* Events: Initialise */
event timeUp;

/* Events: Start */
event start2Evnt;

event startEvnt(CALL_GAMEINIT)
{
	centreViewPos(11*128, 52*128);
//make scavengers and New paradigm allies (just in case!)
	createAlliance(enemy1, enemy2);
//set scroll limits
//	setScrollParams(0, 0, 128, 128);			//limit scroll
//set zoom Level 128x128
	setRadarZoom(0);
//stop player building on LZ
	initAllNoGoAreas();
	setLandingZone(10, 51, 12, 53);
//also don't allow building on 1CA's enemy LZs!
	count = 0;
	while (count < numLZ - 1)	//don't go over 7!! SKIP LAST ONE, since changes!
	{
		setNoGoArea((enemyLZX[count]/128) - 1, (enemyLZY[count]/128) - 1, (enemyLZX[count]/128) + 1, (enemyLZY[count]/128) + 1, count + 2);	//count+2 so doesn't set NP's LZ (since changes later!)
		count = count + 1;
	}
//set no time limits (can carry over from previous missions if not set!)
	setReinforcementTime(-1);
	setMissionTime(timeLimit);			//set Mission time limit

//add enemy transport (once!)
	setNoGoArea((enemyLZX[0] / 128) - 1, (enemyLZY[0] / 128) - 1, (enemyLZX[0] / 128) + 1, (enemyLZY[0] / 128) + 1, enemy2);
	transportDroid = addDroidToMissionList(transporter, enemy2);

//allow to build stuff
	setStructureLimits (powerGen,numPow,0);
	setStructureLimits (oilDerrick,numExt,0);
	setStructureLimits (research,numRes,0);
	setStructureLimits (factory,numFac,0);
	setStructureLimits(command, 1, player);
	enableStructure(command, player);
	enableStructure(powerGen,0);
	enableStructure(oilDerrick,0);
	enableStructure(research,0);
	enableStructure(factory,0);
	//enableStructure(powerModuleHack, 0);

	setPowerLevel(pow1, enemy1);
	setPowerLevel(pow2, enemy2);
	setEventTrigger(startEvnt, inactive);
	addMessage(obj0Msg, PROX_MSG, player, false);	//show enemy Position
	addMessage(MissionBrief, MISS_MSG, 0, true);
}

event start2Evnt(CALL_VIDEO_QUIT)
{
//remove first part of two part message, and play second part
	setEventTrigger(start2Evnt, inactive);
	removeMessage(MissionBrief, MISS_MSG, 0);
	addMessage(MissionBrief2, MISS_MSG, 0, true);
}

event removeObj0(obj0Trig)
{
	removeMessage(obj0Msg, PROX_MSG, player);
	setEventTrigger(removeObj0, inactive);
}

/*Events:*/

/* Events: Artifacts */
event art1TakeEvnt(inactive)
{
	numart=numart+1;
	//playSound(art1Snd2, player);
	playSoundPos(art1Snd2, player, art1ID.x, art1ID.y, art1ID.z);
	destroyFeature(art1ID);
	//removeMessage(art1Msg, PROX_MSG, player);
	enableResearch(art1Comp, player);
	setEventTrigger(art1TakeEvnt, inactive);
}

event art1PlaceEvnt(art1PlaceTrig)
{
	//place artifact crate, and allow check for prox
	art1ID=addFeature(crate, art1X, art1Y);
	//setEventTrigger(art1SeenEvnt, art1SeenTrig);
	setEventTrigger(art1TakeEvnt, art1TakeTrig);
	setEventTrigger(art1PlaceEvnt, inactive);
}

event art2TakeEvnt(inactive)
{
	numart=numart+1;
	//playSound(art2Snd2, player);
	playSoundPos(art2Snd2, player, art2ID.x, art2ID.y, art2ID.z);
	destroyFeature(art2ID);
	//removeMessage(art2Msg, PROX_MSG, player);
	enableResearch(art2Comp, player);
	setEventTrigger(art2TakeEvnt, inactive);
}

event art2PlaceEvnt(art2PlaceTrig)
{
	//place artifact crate, and allow check for prox
	art2ID=addFeature(crate, art2X, art2Y);
	//setEventTrigger(art2SeenEvnt, art2SeenTrig);
	setEventTrigger(art2TakeEvnt, art2TakeTrig);
	setEventTrigger(art2PlaceEvnt, inactive);
}

event art3TakeEvnt(inactive)
{
	numart=numart+1;
	//playSound(art3Snd2, player);
	playSoundPos(art3Snd2, player, art3ID.x, art3ID.y, art3ID.z);
	destroyFeature(art3ID);
	//removeMessage(art3Msg, PROX_MSG, player);
	enableResearch(art3Comp, player);
	setEventTrigger(art3TakeEvnt, inactive);
}

event art3PlaceEvnt(art3PlaceTrig)
{
	//place artifact crate, and allow check for prox
	art3ID=addFeature(crate, art3X, art3Y);
	//setEventTrigger(art3SeenEvnt, art3SeenTrig);
	setEventTrigger(art3TakeEvnt, art3TakeTrig);
	setEventTrigger(art3PlaceEvnt, inactive);
}
/*
event art4TakeEvnt(inactive)
{
	numart=numart+1;
	//playSound(art4Snd2, player);
	playSoundPos(art4Snd2, player, art4ID.x, art4ID.y, art4ID.z);
	destroyFeature(art4ID);
	//removeMessage(art4Msg, PROX_MSG, player);
	enableResearch(art4Comp, player);
	setEventTrigger(art4TakeEvnt, inactive);
}

event art4PlaceEvnt(art4PlaceTrig)
{
	//place artifact crate, and allow check for prox
	art4ID=addFeature(crate, art4X, art4Y);
	//setEventTrigger(art4SeenEvnt, art4SeenTrig);
	setEventTrigger(art4TakeEvnt, art4TakeTrig);
	setEventTrigger(art4PlaceEvnt, inactive);
}
*/

event art5TakeEvnt(inactive)
{
	numart=numart+1;
	//playSound(art5Snd2, player);
	playSoundPos(art5Snd2, player, art5ID.x, art5ID.y, art5ID.z);
	destroyFeature(art5ID);
	//removeMessage(art5Msg, PROX_MSG, player);
	enableResearch(art5Comp, player);
	setEventTrigger(art5TakeEvnt, inactive);
}

event art5PlaceEvnt(art5PlaceTrig)
{
	//place artifact crate, and allow check for prox
	art5ID=addFeature(crate, art5X, art5Y);
	//setEventTrigger(art5SeenEvnt, art5SeenTrig);
	setEventTrigger(art5TakeEvnt, art5TakeTrig);
	setEventTrigger(art5PlaceEvnt, inactive);
}








event wonYetEvnt;

/* Events: Win or Lose */

event nextLevEvnt(inactive)		//assumes victory already checked
{
	pause(20);		//increased to allow all audio before won
	// give bonus research (if req'd)
	count = 0;
	while (count < numResP0)
	{
		enableResearch(resP0[count], 0);
		count = count +1;
	}

	gameLevel=gameLevel+1;		//flag next part of map
	//removing message unnecessary
	//removeMessage(MissionBrief2, MISS_MSG, player);
	startMission(CAMP_EXPAND, NextLev);
	//End game here for now! (don't try next mission)
	//gameOver(true);

	setEventTrigger(nextLevEvnt, inactive);
}


event gameLost(inactive)
{
//	addMessage(endMsg, MISS_MSG, 0, true);
//	pause(10);
//	gameOver(false);
	gameOverMessage(endMsg, MISS_MSG, 0, false);
	setEventTrigger(gameLost, inactive);
}

event lostYetEvnt(winLoseTrig)
{
	if (not anyDroidsLeft(player))
	{
		if (not anyStructButWallsLeft(player))
		{
			setEventTrigger(wonYetEvnt,inactive);
			setEventTrigger(gameLost, gameLostTrig);	//waits 2 seconds before ending
			setEventTrigger(lostYetEvnt, inactive);
			setEventTrigger(timeUp, inactive);
		}

	}
}

event wonYetEvnt(winLoseTrig) // have all enemies lost yet?
{								
	if (not anyDroidsLeft(enemy2))
	{
		if (not anyStructButWallsLeft(enemy2))
	   	{
	   	  	if (not anyDroidsLeft(enemy1))
			{
				if (not anyStructButWallsLeft(enemy1))
				{
					if (numart==4)	// a victory condition
					{
						setEventTrigger(lostYetEvnt, inactive);
						setEventTrigger(nextLevEvnt, winLoseTrig);
						setEventTrigger(wonYetEvnt, inactive);
						setEventTrigger(timeUp, inactive);
					}
				}
			}
		}
	}
}



event cheatEvnt(CALL_MISSION_START)	//cheat button ctrl M
{
	setEventTrigger(nextLevEvnt, winLoseTrig);
	setEventTrigger(cheatEvnt, inactive);
}

/* Base Under Attack */
event baseHit(CALL_STRUCT_ATTACKED, selectedPlayer, ref hitStruc, ref attackerObj)
{
	if (t >= 20)
	{
		t=0;
		if (hitStruc != NULLOBJECT)
		{
			playSoundPos(attackSnd1, selectedPlayer, hitStruc.x, hitStruc.y, hitStruc.z);	//show position if still alive
		}
		else
		{
			playSound(attackSnd1, selectedPlayer);
		}
	}
}

event everySec(every, 10)
{
	t=t+1;
}

event seeBaseHit(CALL_MISSION_END)
{
//go to where the structure being attacked is on CTRL B
	if (hitStruc!=NULLOBJECT)
	{
		centreView(hitStruc);
		t=0;			//flag known about!
	}
}




/* AI EVENTS */

// event prototypes
//event enemy1AttackBase;
event enm1bFactEvnt;
event enm1cFactEvnt;
event enm2bFactEvnt;
event enm2cFactEvnt;
//event enm2dFactEvnt;

//event setBuild1;
//event setBuild2;
//event setBuild3;

event startup(CALL_GAMEINIT)	//(init)
{
//setass here since factory may be dead if done later!!!
	setAssemblyPoint (enm1a, 13248, 13632);
	//setAssemblyPoint (enm1b, 8384, 704);	//in good place
	setAssemblyPoint (enm1c, 8384, 704);

	//setAssemblyPoint (enm2a, 13504, 13248);	//12736, 14016);
	setAssemblyPoint (enm2b, 12736, 11456);
	setAssemblyPoint (enm2c, 9920, 3136);
	//setAssemblyPoint (enm2d, 14528, 3776);

	randomiseSeed();
	//make scavengers allies with NP
	createAlliance(enemy1, enemy2);
//set attack level for scavs
	atkTot = 4;
//make up starting forces

//Send sensor droids to new positions
	//orderDroidLoc(sensor1, DORDER_SCOUT, 6976, 13376);
	//orderDroidLoc(sensor2, DORDER_SCOUT, 6592, 14400);

//Setup Mortar group
	groupAddArea(IDF1, enemy2, 8384, 15168, 9024, 15680);
	//orderGroupLoc(IDF1, DORDER_SCOUT, 7232, 15168);		//then move into position (no good other way round!)

//set up strike force (scout)
	groupAddArea(Strike1[0], enemy2, 8384, 13760, 8512, 14144);	//rocket-sensor scout force
	groupAddArea(Strike2[0], enemy2, 8640, 13760, 8896, 14144);	//rocket-sensor  force
	groupAddArea(Strike1[1], enemy2, 9280, 13760, 9920, 14144);	//halftrack 'scout' force
	groupAddArea(Strike2[1], enemy2, 9280, 14272, 9920, 14656);	//tank force

	scoutSector[0] = 6;	//first scout to south of players base
	as1 = scoutSector[0];	//set going immediately!
	asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1]);
	asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1]);
	orderGroupLoc(Strike1[0], DORDER_SCOUT, asX, asY);

	as1 = 3;	//5;		//move followup force out to 2 sectors back
	asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1]);
	asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1]);
	//orderGroupLoc(Strike2[0], DORDER_SCOUT, asX, asY);

	scoutSector[1] = 0;	//3;//second scout South 1B 
	sectInc[0] = 1;			//sector increment to get to next one
	sectInc[1] = 1;

	//setGroupSecondary(Strike1, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
//scout player's base
	groupAddArea(Ambush1, enemy2, 10944, 10816, 11712, 11712);
	AmbushTot=Ambush1.members;		//keep note of max for checking casualties later
	//orderGroupObj(Ambush1, DORDER_FIRESUPPORT, sensor1);	//use sensor droid for firesupport?

	//groupAddArea(Reserve1, enemy2, 9280, 13632, 9664, 14144);

//set up Scavenger forces
	groupAddArea(Scav1, enemy1, 13120, 13376, 12896, 13587);	//4 Jeeps
	groupAddArea(Scav2, enemy1, 13730, 9419, 13863, 9505);		//4 Rocket Buggies
	//setGroupSecondary(Scav2, DSO_HALTTYPE, DSS_HALT_HOLD);		//Hold position
	Scav2Health=Scav2.health;					//keep track of casualties

// player specific technology startups
	count = 0;
	while (count < numtecE1)
	{
		completeResearch(tecE1[count], enemy1);
		count = count +1;
	}
	count = 0;
	while (count < numtecE2)
	{
		completeResearch(tecE2[count], enemy2);
		count = count +1;
	}

	initGetFeature(oilRes, enemy2, enemy2);			//build on oil resources setup
}

//event orderEvnt4;
event enm1bFactEvnt;
event enm1cFactEvnt;
event orderEvnt1(orderTrig1)
{
//follow attack force when they're a bit ahead
	orderGroupLoc(Ambush1, DORDER_SCOUT, 8352, 13880);
	setEventTrigger(enm1bFactEvnt, enm1bFactTrig);		//start mid scavs building also!
	playerX = 8352;							//change attack point to ravine ambush
	playerY = 13880;
	//setEventTrigger(orderEvnt4, orderTrig4);
	setEventTrigger(orderEvnt1, inactive);
}

// deal with a droid being built by enemy1
event enemy1build(CALL_NEWDROID, enemy1, ref newDroid,ref newDroidFactory)
{
	groupAddDroid(enemy1Build, newDroid);
	if (enemy1Build.members >= atkTot)
	{
		groupAddGroup(enemy1Attack, enemy1Build);
	//do attack force decision here!
		if (atkTot < enemy1Tot)
		{
			atkTot = atkTot + 1;
		}
		if (targetCount[0] > 0)
		{
			orderGroupLoc(enemy1Attack, DORDER_SCOUT, targetX[0][0], targetY[0][0]);	//only use first target seen!
		}
		else
		{
			orderGroupLoc(enemy1Attack, DORDER_SCOUT, playerX, playerY);	//go to set position
		}
	}
}

// deal with a droid being built by enemy2
event enemy2build(CALL_NEWDROID, enemy2, ref newDroid,ref newDroidFactory)
{
//check for New Truck Built!!!!
	if (newDroid.droidType == DROID_CONSTRUCT) 
	{
		if (enemyTruck1 == NULLOBJECT)
		{
			enemyTruck1=newDroid;
			//setEventTrigger(setBuild1, buildTrig);
		}
/*
		else if  (enemyTruck2 == NULLOBJECT)
		{
			enemyTruck2=newDroid;
			setEventTrigger(setBuild2, buildTrig);
		}
		else if  (enemyTruck3 == NULLOBJECT)
		{
			enemyTruck3=newDroid;
			setEventTrigger(setBuild3, buildTrig);
		}
*/

	}
	else
	//just normal droid so add to attack etc.
	{
		groupAddDroid(enemy2Build, newDroid);
		if (enemy2Build.members >= 4)
		{
			if (enemy2Attack.members >= 4)
			{
				groupAddGroup(enemy2Attack, enemy2Build);		//keep defemsive force
			}
			else
			{
				sn = 0;
				while (sn < st)
				{
					if (Strike1[sn].members == 0)
					{
						groupAddGroup(Strike1[sn], enemy2Build);		//rebuild scout and strike groups!
						scoutSector[sn] = 0;					//start from 1st sector again!
						sectInc[sn] = 1;
					}
					else if (Strike2[sn].members == 0)
					{
						groupAddGroup(Strike2[sn], enemy2Build);
					}
					sn = sn +1;
				}
			}
		}
	}
}

/* events for build lists start here */
/* Enemy 1 Scavengers*/
//build list Scav South factory!
event enm1aFactEvnt(inactive)
{
	enm1aDestroyed = buildingDestroyed (enm1aID, enemy1);
	if 	(enm1aDestroyed)
	{
		setEventTrigger(enm1bFactEvnt, enm1bFactTrig);		//start other factory!!
 		setEventTrigger(enm1aFactEvnt, inactive);
	}
	else if (structureIdle(enm1a) and (enemy1Build.members+enemy1Attack.members)<enemy1Tot)
	{
		if (enm1aState == 0)
		{
			buildDroid (BusCan, enm1a, enemy1, 1);
			enm1aState = 1;
		}
		else if (enm1aState== 1)
		{
			buildDroid (rktJeep, enm1a, enemy1, 1);
			enm1aState = 2;

		}
		else if (enm1aState == 2)
		{
			buildDroid (trike, enm1a, enemy1, 3);	
			enm1aState = 3;
		}
		else
		{
			buildDroid (buggy, enm1a, enemy1, 2);	
			enm1aState = 0;
		}
	}
}

event enm1aStartEvnt(enm1aStartTrig)
{
	setEventTrigger(enm1aFactEvnt, enm1aFactTrig);
	setEventTrigger(enm1aStartEvnt, inactive);
}

//build list Scav mid Factory
event enm1bFactEvnt(inactive)
{
	enm1bDestroyed = buildingDestroyed (enm1bID, enemy1);
	if 	(enm1bDestroyed)
	{
		setEventTrigger(enm1cFactEvnt, enm1cFactTrig);		//start other factory!!
 		setEventTrigger(enm1bFactEvnt, inactive);
	}
	else if (structureIdle(enm1b) and (enemy1Build.members+enemy1Attack.members)<enemy1Tot)
	{
		if (enm1bState == 0)
		{
			buildDroid (FireCan, enm1b, enemy1, 1);
			enm1bState = 1;

		}
		else if (enm1bState== 1)
		{
			buildDroid (rktBuggy, enm1b, enemy1, 1);
			enm1bState = 2;
		}
		else if (enm1bState == 2)
		{
			buildDroid (jeep, enm1b, enemy1, 2);	
			enm1bState = 3;
		}
		else
		{
			buildDroid (bloke, enm1b, enemy1, 3);	
			enm1bState = 0;
		}
	}
}

event enm1bStartEvnt(enm1bStartTrig)
{
	setEventTrigger(enm1bFactEvnt, enm1bFactTrig);
	setEventTrigger(enm1bStartEvnt, inactive);
}

//build list Scav north Factory
event enm1cFactEvnt(inactive)
{
	enm1cDestroyed = buildingDestroyed (enm1cID, enemy1);
	if 	(enm1cDestroyed)
	{
 		setEventTrigger(enm1cFactEvnt, inactive);
	}
	else if (structureIdle(enm1c) and (enemy1Build.members+enemy1Attack.members)<enemy1Tot)
	{
		if (enm1cState == 0)
		{
			buildDroid (FireCan, enm1c, enemy1, 1);
			enm1cState = 1;

		}
		else if (enm1cState== 1)
		{
			buildDroid (rktBuggy, enm1c, enemy1, 1);
			enm1cState = 2;
		}
		else if (enm1cState == 2)
		{
			buildDroid (BusCan, enm1c, enemy1, 2);	
			enm1cState = 3;
		}
		else
		{
			buildDroid (trike, enm1c, enemy1, 3);	
			enm1cState = 0;
		}
	}
}

event enm1cStartEvnt(enm1cStartTrig)
{
	setEventTrigger(enm1cFactEvnt, enm1cFactTrig);
	setEventTrigger(enm1cStartEvnt, inactive);
}



/* New paradigm Factories */
//build list NP South factory!
// 0 = tanks
// 1 = rocket tanks
/* NO LONGER THERE!
event enm2aFactEvnt(inactive)
{
	enm2aDestroyed = buildingDestroyed (enm2aID, enemy2);
	if 	(enm2aDestroyed)
	{
		setEventTrigger(enm2cFactEvnt, enm2cFactTrig);	//set next factory to build!
 		setEventTrigger(enm2aFactEvnt, inactive);
	}
	else if (structureIdle(enm2a) and (enemy2Build.members+enemy2Attack.members)<enemy2Tot)
	{
		if (enm2aState == 0)	//ScorpMCan
		{
			buildDroid (ScorpMCan, enm2a, enemy2, 1);
			enm2aState = 1;
		}
		else if (enm2aState == 1)
		{
			buildDroid (BugRktP, enm2a, enemy2, 3);
			enm2aState = 2;
		}
		else if (enm2aState == 2)
		{
			buildDroid (BugHMG, enm2a, enemy2, 3);	
			enm2aState = 0;
		}
		else if (enm2aState == 3)
		{
			buildDroid (scorpTruck, enm2a, enemy2, 1);	//build a replacement truck
			enm2aState = 0;					//set back to normal build
		}
	}
}

event enm2aStartEvnt(wait, 50)		//start producing soon after start of mission
{
	setEventTrigger(enm2aFactEvnt, enm2aFactTrig);
	setEventTrigger(enm2aStartEvnt, inactive);
}
*/

//build list NP central Factory
event enm2bFactEvnt(inactive)
{
	enm2bDestroyed = buildingDestroyed (enm2bID, enemy2);
	if 	(enm2bDestroyed)
	{
		setEventTrigger(enm2cFactEvnt, enm2cFactTrig);		//set next factory to build
 		setEventTrigger(enm2bFactEvnt, inactive);
	}
	else if (structureIdle(enm2b) and (enemy2Build.members+enemy2Attack.members)<enemy2Tot)
	{
		if (enm2bState == 0)
		{
			buildDroid (ScorpLMort, enm2b, enemy2, 3);
			enm2bState= 1;
		}
		else if (enm2bState== 1)
		{
			buildDroid (BugSensor, enm2b, enemy2, 1);
			enm2bState = 2;
		}
		else if (enm2bState == 2)
		{
			buildDroid (ScorpMCan, enm2b, enemy2, 2);
			enm2bState = 0;
		}
		else
		{
			buildDroid (scorpTruck, enm2b, enemy2, 1);
			enm2bState= 0;
		}
	//check for any trucks dead, and set to manufacturing a replacement
		if (enemyTruck1 == NULLOBJECT)	// or (enemyTruck2 == NULLOBJECT) or (enemyTruck3 == NULLOBJECT))
		{
			enm2bState = 3;				//build another one!!
		}
	}
}


event enm2bStartEvnt(enm2bStartTrig)	//(wait, 50)
{
	setEventTrigger(enm2bFactEvnt, enm2bFactTrig);
	setEventTrigger(enm2bStartEvnt, inactive);
}

//build list NP NW Factory
//rocket tanks always
event enm2cFactEvnt(inactive)
{
	enm2cDestroyed = buildingDestroyed (enm2cID, enemy2);
	if 	(enm2cDestroyed)
	{
		//setEventTrigger(enm2dFactEvnt, enm2dFactTrig);		//set next factory to build!
 		setEventTrigger(enm2cFactEvnt, inactive);
	}
	else if ((structureIdle(enm2c) and (enemy2Build.members+enemy2Attack.members)<enemy2Tot)
		and (structureBuilt(powerGen, enemy2)))		//must have at least 1 pow gens!
	{
		if (enm2cState == 0)
		{
			buildDroid (BugRktP, enm2c, enemy2, 3);
			enm2cState = 1;
		}
		else if (enm2cState== 1)
		{
			buildDroid (ScorpMCan2, enm2c, enemy2, 3);
			enm2cState = 2;
		}
		else if (enm2cState == 2)
		{
			buildDroid (ScorpLMort, enm2c, enemy2, 3);
			enm2cState = 0;
		}
		else
		{
			buildDroid (scorpTruck, enm2c, enemy2, 1);
			enm2cState = 0;	
		}
		//check for any trucks dead, and set to manufacturing a replacement
		if (enemyTruck1 == NULLOBJECT)	// or (enemyTruck2 == NULLOBJECT) or (enemyTruck3 == NULLOBJECT))
		{
			enm2cState = 3;				//build another one!!
		}
	}
}

/* use 2B factory destruction to trigger and/or brief 
event enm2cStartEvnt(enm2cStartTrig)
{
	setEventTrigger(enm2cFactEvnt, enm2cFactTrig);
	setEventTrigger(enm2cStartEvnt, inactive);
}
*/

//build list NP NW2 Factory
// 0 or 1 = 2 howitzer, 1 sensor
//      2 = rocket tanks
/* not on map any more!
event enm2dFactEvnt(inactive)
{
	enm2dDestroyed = buildingDestroyed (enm2dID, enemy2);
	if 	(enm2dDestroyed)
	{
 		setEventTrigger(enm2dFactEvnt, inactive);
	}
	else if (structureIdle(enm2d) and (enemy2Build.members+enemy2Attack.members)<enemy2Tot)
	{
		if (enm2dState == 0)
		{
			buildDroid (ScorpLMort, enm2d, enemy2, 3);
			enm2dState= 1;
		}
		else if (enm2dState== 1)
		{
			buildDroid (BugSensor, enm2d, enemy2, 1);
			enm2dState= 2;
		}
		else if (enm2dState == 2)
		{
			buildDroid (BugRktP, enm2d, enemy2, 3);	
			enm2dState= 3;
		}
		else
		{
			buildDroid (ScorpMCan, enm2d, enemy2, 2);
			enm2dState= 0;	
		}
	}
}


event enm2dStartEvnt(enm2dStartTrig)
{
	setEventTrigger(enm2dFactEvnt, enm2dFactTrig);
	setEventTrigger(enm2dStartEvnt, inactive);
}
*/


event lastAttack1(every, 50)
{
//make enemy attack player's base if all enemy buildings destroyed
	if (not anyStructButWallsLeft(enemy1))
	{
		groupAddArea(enemy1Fin, enemy1, 0, 0, 128*128, 128*128);
		orderGroupLoc(enemy1Fin, DORDER_SCOUT, playerX, playerY);
		//setEventTrigger(lastAttack1, inactive);
	}
}

event lastAttack2(every, 50)
{
//make enemy easier to find if all his buildings destroyed
	if (not anyStructButWallsLeft(enemy2))
	{
		groupAddArea(enemy2Fin, enemy1, 0, 0, 128*128, 128*128);
		orderGroupLoc(enemy2Fin, DORDER_SCOUT, playerX, playerY);
		//setEventTrigger(lastAttack2, inactive);
	}
}

//Generic go investigate nearby structures if under attack!

event enm1Hit(CALL_STRUCT_ATTACKED, enemy1, ref hitStruc, ref attackerObj)
{
	//playSound(attackSnd1, 0);	//quick check
//get force nearby
	if (hitStruc!=NULLOBJECT)
	{
//find at least 4 vehicles to defend structure first
		tempx1 = 1 * 128;
		groupAddGroup(dummy1, enemy1Guard);	//empty enemy1Guard group first!
		while ((enemy1Guard.members < 4) and (tempx1 <= 1280))
		{
			groupAddArea(enemy1Guard, enemy1, hitStruc.x - tempx1, hitStruc.y - tempx1, hitStruc.x + tempx1, hitStruc.y + tempx1);
			tempx1 = tempx1 + 128;
			tempy1 = enemy1Attack.members;	//hack to recalculate members in enemy1Guard!!!
		}
		if (attackerObj != NULLOBJECT)
		{
		//attack attacker (if he exists)!!
		orderGroupObj(enemy1Guard, DORDER_ATTACK, attackerObj);
		orderGroupLoc(enemy1Guard, DORDER_SCOUT, attackerObj.x, attackerObj.y);
		}
		else
		{
		//defend structure!!
		orderGroupLoc(enemy1Guard,DORDER_SCOUT, hitStruc.x, hitStruc.y);
		}
	}
}


event enm2Hit(CALL_STRUCT_ATTACKED, enemy2, ref hitStruc, ref attackerObj)
{
//Find a free Truck to Repair Object (in Theory!)
	//playSound(attackSnd1, 0);	//quick check
	if (hitStruc!=NULLOBJECT)
	{

//find at least 4 vehicles to defend structure first
		tempx2 = 1 * 128;
		groupAddGroup(dummy2, enemy2Guard);	//empty enemy2Guard group first!
		while ((enemy2Guard.members < 4) and (tempx2 <= 2560))
		{
			groupAddArea(enemy2Guard, enemy2, hitStruc.x - tempx2, hitStruc.y - tempx2, hitStruc.x + tempx2, hitStruc.y + tempx2);
			tempx2 = tempx2 + 128;
			tempy2 = enemy2Attack.members;	//hack to recalculate members in enemy2Guard!!!
		}

		setGroupSecondary(enemy2Guard, DSO_REPAIR_LEVEL, DSS_REPLEV_HIGH);		//set repair level

		if (attackerObj != NULLOBJECT)
		{
		//attack attacker (if he exists)!!
		//orderGroupObj(enemy2Guard, DORDER_ATTACK, attackerObj);
		orderGroupLoc(enemy2Guard, DORDER_SCOUT, attackerObj.x, attackerObj.y);
		}
		else
		{
		//defend structure!!
		orderGroupLoc(enemy2Guard, DORDER_SCOUT, hitStruc.x, hitStruc.y);
		}

/* AUTO REPAIR NOW SO DON'T BOTHER!!!
//then send a repair droid (if not a wall, corner wall or defence)
		//testStruc = objToStructure(hitStruc);
//.type will never give these values!!!!!!!!!
		//if ((testStruc.type != REF_WALL) and (testStruc.type != REF_WALLCORNER) and (testStruc.type != REF_DEFENSE))
//check not wall, cornerwall or defense!
		if ((numStructsByTypeInArea(player, REF_WALL, hitStruc.x - 10, hitStruc.y - 10, hitStruc.x + 10, hitStruc.y + 10) == 0) and
			(numStructsByTypeInArea(player, REF_WALLCORNER, hitStruc.x - 10, hitStruc.y - 10, hitStruc.x + 10, hitStruc.y + 10) == 0) and
			(numStructsByTypeInArea(player, REF_DEFENSE, hitStruc.x - 10, hitStruc.y - 10, hitStruc.x + 10, hitStruc.y + 10) == 0))
		{
			if (enemyTruck3!=NULLOBJECT)	//not dead
			{
				orderDroidObj(enemyTruck3, DORDER_REPAIR, hitStruc);
			}
			else if (enemyTruck2!=NULLOBJECT)
			{
				orderDroidObj(enemyTruck2, DORDER_REPAIR, hitStruc);
			}
			else if (enemyTruck1!=NULLOBJECT)
			{
				orderDroidObj(enemyTruck1, DORDER_REPAIR, hitStruc);
			}
		}
*/

	}

}

/* Construction lists */

/* now with arrays!!!! */

/* DON'T BOTHER!!!
event buildStruc1(every, 30)
{
	if (enemyTruck1==NULLOBJECT)
	{
		setEventTrigger(setBuild1, inactive);
		setEventTrigger(buildStruc1, inactive);
	}
	else if (comTruck1<numStruc1)
	{
		orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, struc1[comTruck1], struc1X[comTruck1], struc1Y[comTruck1]);
	}
	setEventTrigger(setBuild1, buildTrig);
	setEventTrigger(buildStruc1, inactive);
}

event setBuild1(inactive)
{
	if (enemyTruck1==NULLOBJECT)
	{
		setEventTrigger(setBuild1, inactive);
		setEventTrigger(buildStruc1, inactive);
	}
	else if (enemyTruck1.order == DORDER_NONE)
	{
		comTruck1 = comTruck1+1;
		setEventTrigger(buildStruc1, buildTrig);
		setEventTrigger(setBuild1, inactive);
	}
//check if finished
	if (comTruck1 >= numStruc1)
	{
		setEventTrigger(setBuild1, inactive);
		setEventTrigger(buildStruc1, inactive);
	}
}

event buildStruc2(every, 30)
{
	if (enemyTruck2 == NULLOBJECT)
	{
		setEventTrigger(setBuild2, inactive);
		setEventTrigger(buildStruc2, inactive);
	}
	else if (comTruck2 < numStruc2)
	{
		orderDroidStatsLoc(enemyTruck2, DORDER_BUILD, struc2[comTruck2], struc2X[comTruck2], struc2Y[comTruck2]);
	}
	setEventTrigger(setBuild2, buildTrig);
	setEventTrigger(buildStruc2, inactive);
}

event setBuild2(inactive)
{
	if (enemyTruck2 == NULLOBJECT)
	{
		setEventTrigger(setBuild2, inactive);
		setEventTrigger(buildStruc2, inactive);
	}
	else if (enemyTruck2.order == DORDER_NONE)
	{
		comTruck2 = comTruck2+1;
		setEventTrigger(buildStruc2, buildTrig);
		setEventTrigger(setBuild2, inactive);
	}
//check if finished
	if (comTruck2 >= numStruc2)
	{
		setEventTrigger(setBuild2, inactive);
		setEventTrigger(buildStruc2, inactive);
	}
}

event buildStruc3(every, 30)
{
	if (enemyTruck3 == NULLOBJECT)
	{
		setEventTrigger(setBuild3, inactive);
		setEventTrigger(buildStruc3, inactive);
	}
	else if (comTruck3 < numStruc3)
	{
		orderDroidStatsLoc(enemyTruck3, DORDER_BUILD, struc3[comTruck3], struc3X[comTruck3], struc3Y[comTruck3]);
	}
	setEventTrigger(setBuild3, buildTrig);
	setEventTrigger(buildStruc3, inactive);
}

event setBuild3(inactive)
{
	if (enemyTruck3 == NULLOBJECT)
	{
		setEventTrigger(setBuild3, inactive);
		setEventTrigger(buildStruc3, inactive);
	}
	else if (enemyTruck3.order == DORDER_NONE)
	{
		comTruck3=comTruck3+1;
		setEventTrigger(buildStruc3, buildTrig);
		setEventTrigger(setBuild3, inactive);
	}
//check if finished
	if (comTruck3 >= numStruc3)
	{
		setEventTrigger(setBuild3, inactive);
		setEventTrigger(buildStruc3, inactive);
	}
}
*/

/* done in factory event now!
event checkTrucks(every, 30)
{
//check for any trucks dead, and set to manufacturing a replacement
	if (enemyTruck1 == NULLOBJECT)	// or (enemyTruck2 == NULLOBJECT) or (enemyTruck3 == NULLOBJECT))
	{
		enm2cState = 3;				//build another one!!
		enm2bState = 3;				//build another one!!
	}
}

//This callback doesn't seem to work! Need John to fix!
/*
event checkSensor(CALL_STRUCT_SEEN, player, ref hitStruc, ref viewerObj)
{
	playSound(lostSnd,1);
	if (viewerObj.type == OBJ_DROID)
	{
		testDroid = objToDroid(viewerObj);
		if  (testDroid == sensor2)
		{
			orderDroidObj(sensor2, DORDER_OBSERVE, targetDroid);
		}
	}
}
*/


event scoutAtk1Sectors(every, 150)
{
	sn = 0;
	while (sn < st)	//for all 'st' forces (scout group + heavy group)
	{
		if (Strike1[sn].members == 0)
		{
			groupAddGroup(Strike1[sn], Strike2[sn]);	//make next group in chain the scout group!
		}
		//check all attack areas for enemy
		as1 = scoutSector[sn];
		//if (not (objectInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1])))

		//if ((numStructsButNotWallsInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1]) == 0)
		//	and (numStructsButNotWallsInArea(player, targetX[sn] - 768, targetY[sn] - 768, targetX[sn] + 768, targetY[sn] + 768) == 0))
		//if ((random(100) < 25) and (targetCount[sn] == 0))	//25% chance of moving on if no targets


		//10% chance of scouting past an occupied sector (even if targets!)
		temp1 = numStructsButNotWallsInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1]);
		temp2 = numDroidsInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1]);
		if ((random(100) < 10) or (temp1 == 0) or (temp2 ==0))
		{
			//sector clear so use as a retreat point
			setGroupRetreatPoint(Strike1[sn], Strike1[sn].x, Strike1[sn].y);
			//sector clear so choose another

			scoutSector[sn] = scoutSector[sn] + sectInc[sn];	//keep track of frontline
			if ((scoutSector[sn] >= numAtk1Sects) or (scoutSector[sn] < 0))
			{
			//out of sectors! so work back through them
				sectInc[sn] = - sectInc[sn]; 
				scoutSector[sn] = scoutSector[sn] + sectInc[sn];
			}
		}
		if (idleGroup(Strike1[sn]) >= Strike1[sn].members / 2)
		{
			as1 = scoutSector[sn];
			//order scout forces to random position in this sector
			asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1]);
			asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1]);
			orderGroupLoc(Strike1[sn], DORDER_SCOUT, asX, asY);
		}
		sn = sn +1;
	}
}

event attackAtk1Sector(every, 250)
{
//order heavies to acquired target
	sn = 0;
	while (sn < st)
	{
		if ((idleGroup(Strike2[sn]) >= Strike2[sn].members / 2) or (random(100) < 5))
		{
			if (targetCount[sn] > 0)
			{
//new targetting system!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				//find a target in area
				resetStructTargets();
				if (random(100) < 10)
				{
					setStructTarPref(ST_WALL);		//pick walls occassionally
				}
				hitStruc = structTargetInArea(player, enemy2, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768);
				if (hitStruc != NULLOBJECT)
				{
					orderGroupObj(Strike2[sn], DORDER_ATTACK, hitStruc);
				}
				else	//go to new target
				{
					orderGroupLoc(Strike2[sn], DORDER_SCOUT, targetX[sn][0] - 384 + random(768),
					targetY[sn][0] - 384 + random(768));	//only use first target seen!
				}
			}
			else
			{
			//go to previous scouted sector
				as1 = scoutSector[sn] - sectInc[sn];
				if ((as1 >= numAtk1Sects) or (as1 < 0))
				{
					as1 = scoutSector[sn];
				}
				asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1]);
				asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1]);
				orderGroupLoc(Strike2[sn], DORDER_SCOUT, asX, asY);				//random pos in previous sector
			}
		}
		sn = sn +1;
	}
}

event scavAttack(every, 190)
{
//update targets for scavs also
	if (targetCount[0] > 0)
	{
		orderGroupLoc(enemy1Attack, DORDER_SCOUT, targetX[0][0], targetY[0][0]);	//only use first target seen!
	}
	else
	{
		orderGroupLoc(enemy1Attack, DORDER_SCOUT, playerX, playerY);	//go to set position
	}
}

/*
event flagIDF(wait, 600)
{
	//playSound(wonSnd,0);
	orderGroupObj(IDF1, DORDER_FIRESUPPORT, sensor2);	//use sensor droid for firesupport, once mortars hopefully in position
}
*/

/*				*/
/* New Version using 2D Arrays 	*/
/*				*/



event flagTargets(every, 77)	//(every, 43)
{
//clear targets if any gone (by shuffling down array)
	sn = 0;
	while (sn < st)
	{
		if (targetCount[sn] > 0)
		{
			tempInt = 0;
			while (tempInt < targetCount[sn])
			{
/* OLD SYSTEM
				if (numStructsButNotWallsInArea(player, targetX[sn][tempInt] - 768, targetY[sn][tempInt] - 768,
						targetX[sn][tempInt] + 768, targetY[sn][tempInt] + 768) == 0)
				//(not (objectInRange(player, targetX[sn][tempInt], targetY[sn][tempInt], 6 * 128)))
*/
				//find a target in area
				resetStructTargets();
				setStructTarPref(ST_WALL);		//include walls always
				hitStruc = structTargetInArea(player, enemy2, targetX[sn][tempInt] - 768, targetY[sn][tempInt] - 768,
						targetX[sn][tempInt] + 768, targetY[sn][tempInt] + 768);
				if (hitStruc == NULLOBJECT)
				{
					//target cleared so shuffle down
					count = tempInt;
					while (count < targetCount[sn])
					{
						targetX[sn][count] = targetX[sn][count + 1];
						targetY[sn][count] = targetY[sn][count + 1];
						count = count + 1;
					}
					targetCount[sn] = targetCount[sn] - 1;		//reduce total
				}
				tempInt = tempInt + 1;
			}
		}
//flag new targets, if any (structures and droids but not walls!)
		temp1 = numStructsButNotWallsInArea(player, Strike1[sn].x - 768, Strike1[sn].y - 768, Strike1[sn].x + 768, Strike1[sn].y + 768);
		temp2 = numDroidsInArea(player, Strike1[sn].x - 768, Strike1[sn].y - 768, Strike1[sn].x + 768, Strike1[sn].y + 768);
/* OLD SYSTEM
		if ((targetCount[sn] < targetMax) and ((temp1 > 0) or (temp2 > 0)))
				//(objectInRange(player, Strike1[sn].x, Strike1[sn].y, 6 * 128)))
		{
*/
//new targetting system!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//find a target in area
		resetStructTargets();
		if (random(100) < 10)
		{
			setStructTarPref(ST_WALL);		//pick walls occassionally
		}
		hitStruc = structTargetInArea(player, enemy2, Strike1[sn].x - 768, Strike1[sn].y - 768, Strike1[sn].x + 768, Strike1[sn].y + 768);
		if ((targetCount[sn] < targetMax) and (hitStruc != NULLOBJECT))
		{
			//playSound(lostSnd,1);
			targetX[sn][targetCount[sn]] = Strike1[sn].x;
			targetY[sn][targetCount[sn]] = Strike1[sn].y;
			orderGroupLoc(Strike2[sn], DORDER_SCOUT, targetX[sn][targetCount[sn]], targetY[sn][targetCount[sn]]);
			//if (Strike2[sn].members > Strike1[sn].members)	//make heavies target this, and shoot with scouts (if more than heavies)!
			if ((Strike1[sn].members < temp1) or (Strike1[sn].members < temp2))
			//if more objects than scouts, run away!!!
			{
			//make scout group back off one sector (unless last sector)
				scoutSector[sn] = scoutSector[sn] - sectInc[sn];
				if ((scoutSector[sn] >= numAtk1Sects) or (scoutSector[sn] < 0))
				{
					scoutSector[sn] = scoutSector[sn] + sectInc[sn];
				}
				as1 = scoutSector[sn];
				//order scout forces to random position in this sector
				asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1]);
				asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1]);
				orderGroupLoc(Strike1[sn], DORDER_SCOUT, asX, asY);
				//orderGroup(Strike1[sn], DORDER_RUN);	//run away for a bit!
			}
			else if ((idleGroup(Strike1[sn]) >= Strike1[sn].members / 2) or (random(100) < 5))	//only if not busy or small chance
			{
/* OLD SYSTEM
				orderGroup(Strike1[sn], DORDER_STOP);	//stay where you are (and hopefully kill stuff)
*/
				orderGroupObj(Strike1[sn], DORDER_ATTACK, hitStruc);

			}
			targetCount[sn] = targetCount[sn] +1;
		}	
/* OLD SYSTEM
		//check for targets from heavies also!
		temp1 = numStructsButNotWallsInArea(player, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768);
		temp2 = numDroidsInArea(player, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768);
		if ((targetCount[sn] < targetMax) and ((temp1 > 0) or (temp2 > 0)))
*/
//new targetting system!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//find a target in area
		resetStructTargets();
		if (random(100) < 10)
		{
			setStructTarPref(ST_WALL);		//pick walls occassionally
		}
		hitStruc = structTargetInArea(player, enemy2, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768);
		if ((targetCount[sn] < targetMax) and (hitStruc != NULLOBJECT))
		{
			targetX[sn][targetCount[sn]] = Strike2[sn].x;
			targetY[sn][targetCount[sn]] = Strike2[sn].y;
			orderGroup(Strike2[sn], DORDER_STOP);	//stay where you are (and hopefully kill stuff)
			targetCount[sn] = targetCount[sn] + 1;
		}
		sn = sn +1;
	}

}


event buildDerrick(every, 50)
{

//Build a new powergen if less than one
	if (not (structureBuilt(powerGen, enemy2)))
	{
		if (enemyTruck1 != NULLOBJECT)
		{
			if (enemyTruck1.order == DORDER_NONE)
			{
				tempx1 = enemyTruck1.x;	//build as soon as poss!
				tempy1 = enemyTruck1.y;
				boolResult = pickStructLocation(powerGen, ref tempx1, ref tempy1, enemy2);
				if (boolResult == TRUE)
				{
					orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, powerGen, tempx1, tempy1);
				}
			}
		}
	}

	feature = getFeature(enemy2);					// find unoccupied oil resource that's been seen!
	if(feature != NULLOBJECT)
	{
		if (enemyTruck1 != NULLOBJECT)
		{
			if (enemyTruck1.order == DORDER_NONE)
			{
				if (oilFlag == 0)
				{
					oilX = feature.x;			//keep track of coords for building defences later
					oilY = feature.y;
					orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, oilDerrick, oilX, oilY);	//build a derick
					oilFlag = random(4) + 1;	//number of defences to build nearby
					//need special guard force to go with truck (later!).
				}
				else if (oilFlag < 6)
				{
					tempx1 = oilX + random(1024) - 512;
					tempy1 = oilY + random(1024) - 512;
					temp1 = random(numDefStructs);
					boolResult = pickStructLocation(defStructs[temp1], ref tempx1, ref tempy1, enemy2);
					if(boolResult == TRUE)
					{
						orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, defStructs[temp1], tempx1, tempy1);
						oilFlag = oilFlag - 1;
					}
				}
			}
		}
	}
	else											// feature is null
	{
		initGetFeature(oilRes, enemy2, enemy2);		// start again next time.
	}

}

/* Enemy Base Blips */
event baseLoop(baseTrig)		//update base blips
{
	if (basesDead == numBases)	//all bases gone?
	{
		setEventTrigger(baseLoop, inactive);
	}
	else
	{
		count = 0;
		while (count < numBases)
		{
			if (baseFlag[count] == 0)
			{
				if (seenStructInArea(player, basePlayer[count], FALSE,
					regionsX1[baseRegion[count]], regionsY1[baseRegion[count]],
					regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]))
				{
					addMessage(baseMsg[count], PROX_MSG, player, false);
					if (baseWav1[count] >= 0)
					{
						//playSound(baseSnd[baseWav1[count]], player);
						//tricky one since don't have coords! Use middle of region??
						playSoundPos(baseSnd[baseWav1[count]], player, (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2,
											(regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2, 0);
					}
					baseFlag[count] = 1;
				}
			}
			if (baseFlag[count] == 1)
			{
				if (numStructsButNotWallsInArea(basePlayer[count],
					regionsX1[baseRegion[count]], regionsY1[baseRegion[count]],
					regionsX2[baseRegion[count]], regionsY2[baseRegion[count]])== 0)
				{
					basesDead = basesDead + 1;
					baseFlag[count] = 2;
					if (baseWav2[count] >= 0)
					{
						//playSound(baseSnd[baseWav2[count]], player);
						//tricky one since don't have coords! Use middle of region??
						playSoundPos(baseSnd[baseWav2[count]], player, (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2,
											(regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2, 0);
					}
					removeMessage(baseMsg[count], PROX_MSG, player);
					killStructsInArea(basePlayer[count], REF_WALL, 		//remove walls and building features in base
						regionsX1[baseRegion[count]], regionsY1[baseRegion[count]],
						regionsX2[baseRegion[count]], regionsY2[baseRegion[count]],
						TRUE, TRUE);
					killStructsInArea(basePlayer[count], REF_WALLCORNER,	//remove corner walls in base
						regionsX1[baseRegion[count]], regionsY1[baseRegion[count]],
						regionsX2[baseRegion[count]], regionsY2[baseRegion[count]],
						TRUE, FALSE);

				}
			}
			count = count + 1;
		}
	}	
}

/* Transports */
/* group landed enemy units and get going! */
event groupTrans(CALL_TRANSPORTER_LANDED, enemy2Build, enemy2)
{
	//playSound(warnSnd, player);
	//tricky one since the LZ moves later, but uses this same event
	playSoundPos(warnSnd, player, enemyLZX[LZpos], enemyLZY[LZpos], 0);
	pause(10);
//use random to figure out which groups to go into
	temp = random(3);
	if (temp == 0)
	{
		groupAddGroup(Strike1[0], enemy2Build);		//rebuild scout and strike groups!
		scoutSector[0] = 0;					//start from 1st sector again!
		sectInc[0] = 1;
	}
	else if (temp == 1)
	{
		groupAddGroup(Strike1[1], enemy2Build);		//rebuild scout and strike groups!
		scoutSector[1] = 0;					//start from 1st sector again!
		sectInc[1] = 1;
	}
	else if (temp == 2)
	{
		groupAddGroup(Strike2[0], enemy2Build);
	}
	else
	{
		groupAddGroup(Strike2[1], enemy2Build);
	}
}

event landTrans(inactive)
{
    if (transportDroid != NULLOBJECT)
    {
	    if (not transOnMap)		//make sure transporter not still on map!
	    {
		    //transportDroid = addDroidToMissionList(transporter, enemy2);
		    temp1 = 1 + random(5);	//range 1 to 5
		    temp2 = 8 - temp1;	//make rest upto 8
		    count =0;
		    while (count < temp1)
		    {
			    reinforceTemplate = scout[random(numScout)];	//random selection of scouts
			    loadDroid = addDroidToMissionList(reinforceTemplate, enemy2);
                if (loadDroid != NULLOBJECT)
                {
			        addDroidToTransporter(transportDroid, loadDroid);
                }
			    count = count + 1;
		    }
		    reinforceTemplate = heavy[random(numHeavy)];	//use same selection for all heavies
		    count =0;
		    while (count < temp2)
		    {
			    loadDroid = addDroidToMissionList(reinforceTemplate, enemy2);
                if (loadDroid != NULLOBJECT)
                {
    			    addDroidToTransporter(transportDroid, loadDroid);
                }
			    count = count + 1;
		    }
    //call in transport
		    setTransporterExit(1, 126, 20 + random(32));
		    flyTransporterIn(1, 126, 60 + random(32), false);
		    transOnMap = TRUE;
		    setEventTrigger(landTrans, landTransTrig);	//5 mins until next one
	    }
    }
}


event startTrans1(startTransTrig1)
{
//need Warning message here!!!!
	playSound(incomingSnd, player);
	LZpos = 0;	//used to keep track of where the LZ is for F12
	pause(20);
	addMessage(MissionBrief4, MISS_MSG, 0, true);
	addMessage(obj1Msg, PROX_MSG, player, false);	//show enemy LZ
	setNoGoArea((enemyLZX[0] / 128) - 1, (enemyLZY[0] / 128) - 1, (enemyLZX[0] / 128) + 1, (enemyLZY[0] / 128) + 1, enemy2);
	setEventTrigger(landTrans, landTransTrig2);
	setEventTrigger(startTrans1, inactive);
}

event startTrans2(startTransTrig2)
{
//need Warning message here!!!!
	playSound(incomingSnd, player);
	LZpos = 6;	//used to keep track of where the LZ is for F12
	pause(20);
	addMessage(MissionBrief3, MISS_MSG, 0, true);
	addMessage(obj2Msg, PROX_MSG, player, false);	//show enemy LZ
	//move LZ
	setNoGoArea((enemyLZX[6] / 128) - 1, (enemyLZY[6] / 128) - 1, (enemyLZX[6] / 128) + 1, (enemyLZY[6] / 128) + 1, enemy2);
	setEventTrigger(landTrans, landTransTrig2);
	setEventTrigger(startTrans2, inactive);
}

event stopTrans1(stopTransTrig1)
{
	removeMessage(obj1Msg, PROX_MSG, player);
	setEventTrigger(landTrans, inactive);
	setEventTrigger(stopTrans1, inactive);
}

event stopTrans2(stopTransTrig2)
{
	removeMessage(obj2Msg, PROX_MSG, player);
	setEventTrigger(landTrans, inactive);
	setEventTrigger(stopTrans2, inactive);
}

event transOff(CALL_TRANSPORTER_OFFMAP, enemy2)
{
	transOnMap = FALSE;

}

event timeUp(CALL_MISSION_TIME)
{
	setEventTrigger(wonYetEvnt,inactive);
	setEventTrigger(lostYetEvnt,inactive);
	setEventTrigger(gameLost, gameLostTrig);
	setEventTrigger(timeUp, inactive);
}
